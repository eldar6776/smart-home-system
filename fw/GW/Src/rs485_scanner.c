/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.22                          *
*        Compiled Jul  4 2013, 15:16:01                              *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "DIALOG.h"
#include "common.h"
#include "RS485_Scaner.h"
#include "uart.h"
#include "hotel_room_controller.h"
#include "rubicon_address_list.h"

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { FRAMEWIN_CreateIndirect, "RS485_Scaner", ID_FRAMEWIN_0, 0, 0, 480, 272, 0, 0x0, 0 },
  { LISTVIEW_CreateIndirect, "Listview", ID_LISTVIEW_0, 1, 1, 465, 145, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "START ADDRESS", ID_TEXT_0, 20, 150, 90, 20, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "END ADDRESS", ID_TEXT_1, 145, 150, 80, 20, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "OLD ADDRESS", ID_TEXT_2, 20, 195, 80, 20, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "NEW ADDRESS", ID_TEXT_3, 145, 195, 80, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "SCAN", ID_BUTTON_0, 260, 165, 80, 30, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "SET", ID_BUTTON_1, 260, 210, 80, 30, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "EXIT", ID_BUTTON_2, 380, 210, 80, 30, 0, 0x0, 0 },
  { SPINBOX_CreateIndirect, "Spinbox", ID_SPINBOX_0, 20, 165, 80, 30, 0, 0x0, 0 },
  { SPINBOX_CreateIndirect, "Spinbox", ID_SPINBOX_1, 20, 210, 80, 30, 0, 0x0, 0 },
  { SPINBOX_CreateIndirect, "Spinbox", ID_SPINBOX_2, 145, 165, 80, 30, 0, 0x0, 0 },
  { SPINBOX_CreateIndirect, "Spinbox", ID_SPINBOX_3, 145, 210, 80, 30, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "UPDATE", ID_BUTTON_3, 380, 165, 80, 30, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
	WM_HWIN hItem;
	int     NCode;
	int     Id;
	int 	ret_val1, ret_val2, ret_val3, bcnt;
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'Listview'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_LISTVIEW_0);
    LISTVIEW_AddColumn(hItem, 60, "Address", GUI_TA_HCENTER | GUI_TA_VCENTER);
    LISTVIEW_AddColumn(hItem, 200, "Hardware Version", GUI_TA_HCENTER | GUI_TA_VCENTER);
    LISTVIEW_AddColumn(hItem, 200, "Firmware Version", GUI_TA_HCENTER | GUI_TA_VCENTER);
    LISTVIEW_AddRow(hItem, NULL);
    LISTVIEW_SetGridVis(hItem, 1);
	hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_0);
	SPINBOX_SetRange(hItem, 10, 65500);
	SPINBOX_SetValue(hItem, 10);
	hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_1);
	SPINBOX_SetRange(hItem, 10, 65500);
	SPINBOX_SetValue(hItem, 10);
	hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_2);
	SPINBOX_SetRange(hItem, 10, 65500);
	SPINBOX_SetValue(hItem, 10);
	hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_3);
	SPINBOX_SetRange(hItem, 10, 65500);
	SPINBOX_SetValue(hItem, 10);
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_LISTVIEW_0: // Notifications sent by 'Listview'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_SEL_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_0: // Notifications sent by 'SCAN'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		p_rubicon_buffer = rubicon_ctrl_buffer;
		while(p_rubicon_buffer < rubicon_ctrl_buffer + sizeof(rubicon_ctrl_buffer)) *p_rubicon_buffer++ = NULL;
		p_rubicon_buffer = rubicon_ctrl_buffer;
		hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_0);
		ret_val1 = SPINBOX_GetValue(hItem);
		hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_2);
		ret_val2 = SPINBOX_GetValue(hItem);
		ret_val3 = RUBICON_ScanForNewController(ret_val1, ret_val2);
	  
		if(ret_val3 != 0)
		{
			Int2Str(rubicon_ctrl_buffer, rubicon_firmware_update_address_list[0]);
			hItem = WM_GetDialogItem(pMsg->hWin, ID_LISTVIEW_0);
			LISTVIEW_SetItemText(hItem, 0, 0, rubicon_ctrl_buffer);
			p_rubicon_buffer = rubicon_ctrl_buffer;
			while(p_rubicon_buffer < rubicon_ctrl_buffer + sizeof(rubicon_ctrl_buffer)) *p_rubicon_buffer++ = NULL;
			ret_val1 = 7;
			ret_val2 = 0;
			while(ret_val1 < 34) rubicon_ctrl_buffer[ret_val2++] = rx_buffer[ret_val1++];
			LISTVIEW_SetItemText(hItem, 1, 0, rubicon_ctrl_buffer);
			p_rubicon_buffer = rubicon_ctrl_buffer;
			while(p_rubicon_buffer < rubicon_ctrl_buffer + sizeof(rubicon_ctrl_buffer)) *p_rubicon_buffer++ = NULL;
			ret_val1 = 47;
			ret_val2 = 0;
			while(ret_val1 < 71) rubicon_ctrl_buffer[ret_val2++] = rx_buffer[ret_val1++];
			LISTVIEW_SetItemText(hItem, 2, 0, rubicon_ctrl_buffer);
		}
		
		
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_1: // Notifications sent by 'SET'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		p_rubicon_buffer = rubicon_ctrl_buffer;
		while(p_rubicon_buffer < rubicon_ctrl_buffer + sizeof(rubicon_ctrl_buffer)) *p_rubicon_buffer++ = NULL;
		p_rubicon_buffer = rubicon_ctrl_buffer;
	  
		hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_1);
		ret_val1 = SPINBOX_GetValue(hItem);
		Int2Str(rubicon_ctrl_buffer, ret_val1);
	  
		bcnt = 0;
		while(rubicon_ctrl_buffer[bcnt] != NULL) ++bcnt;
		++bcnt;
	  
		hItem = WM_GetDialogItem(pMsg->hWin, ID_SPINBOX_3);
		ret_val2 = SPINBOX_GetValue(hItem);
		Int2Str(&rubicon_ctrl_buffer[bcnt], ret_val2);
	  
		rubicon_ctrl_request = RUBICON_SET_RS485_CONFIG;
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_2: // Notifications sent by 'EXIT'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_SPINBOX_0: // Notifications sent by 'Spinbox'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_MOVED_OUT:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_SPINBOX_1: // Notifications sent by 'Spinbox'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_MOVED_OUT:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_SPINBOX_2: // Notifications sent by 'Spinbox'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_MOVED_OUT:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_SPINBOX_3: // Notifications sent by 'Spinbox'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_MOVED_OUT:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
	case ID_BUTTON_3: // Notifications sent by 'UPDATE'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateRS485_Scaner
*/
WM_HWIN CreateRS485_Scaner(void);
WM_HWIN CreateRS485_Scaner(void) {
	WM_HWIN hWin;

	hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
	return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
